package slogdiscard

import (
	"context"
	"log/slog"
)

// если горит красным, значит пока не используется в проекте(вероятнее всего для тестов)

func NewDiscardLogger() slog.Logger {
	return slog.New(NewDiscardHandler()) // здесь происходит создание логгера, с помощью slog.New, который вызывает функцию, которая возвращает, пустую структуру DiscardHandler. Таким образом, NewDiscardLogger позволяет вам получить логгер, который будет игнорировать все входящие сообщения.
}

type DiscardHandler struct { // Эта структура представляет собой обработчик логов, который не выполняет никаких действий с входящими записями лога. Она фактически "отбрасывает" все логи. Поскольку структура пустая, она не хранит никаких данных и не имеет состояния. Все ее методы просто игнорируют входные данные.
}

func NewDiscardHandler() slog.Handler { // Эта функция создает и возвращает новый экземпляр DiscardHandler, который реализует интерфейс slog.Handler.
	return &DiscardHandler{}
}

func (h *DiscardHandler) Handle(_ context.Context, _ slog.Record) error { // Этот метод вызывается для обработки записи лога. Первый аргумент — это контекст (context.Context), который может содержать информацию о запросе или времени выполнения. Второй аргумент — это запись лога (slog.Record), содержащая информацию о сообщении лога.
	return nil
}

func (h *DiscardHandler) WithAttrs(_ []slog.Attr) slog.Handler { // Этот метод позволяет добавлять атрибуты к обработчику логов. Аргументы: Он принимает массив атрибутов ([]slog.Attr), но не использует их. Как работает: Метод просто возвращает сам объект обработчика (h), что означает, что атрибуты игнорируются.
	return h
}

func (h *DiscardHandler) WithGroup(_ string) slog.Handler { // Этот метод позволяет группировать логи по определенному имени группы. Аргументы: Он принимает строку (имя группы), но ничего с ней не делает.
	return h
}

func (h *DiscardHandler) Enable(_ slog.Level) bool { // Этот метод определяет, включен ли обработчик на определенном уровне логирования. Аргументы: Он принимает уровень логирования (slog.Level), но не использует его.
	return false
}
