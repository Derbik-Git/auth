package grpcapp // вместо того, что бы генерировать gRPC сервер в main.go, мы генерируем и собираем его в отдельном файле app.go что бы разгрузить main.go

import (
	authgrpc "GRPC/sso/internal/grpc/auth"
	"fmt"
	"net"

	"log/slog"

	"google.golang.org/grpc"
)

// пример испоьзования в main.go func main() { grpc := grpc.NewApp(log, port)

type App struct {
	log        *slog.Logger
	gRPCServer *grpc.Server
	port       int // тут мы передаём порт, который мы получили из main.go
}

// Николай говорил что можно так же определить интерфейс Auth здесь и просто передать его в функцию ниже(просто скопировать этот интерфес из authgrpc и ставить над функцией(где я щас пишу этот текст)
func NewApp(log *slog.Logger, authService authgrpc.Auth, port int) *App { //тут мы передаём 2 параметра потому что они у нас готовые лежат в main.go, а grpc параметр собирается в этой функции дабы не делать этого в main.go
	gRPCServer := grpc.NewServer()

	authgrpc.Register(gRPCServer, authService) // тут мы регистрируем наши сервисы в gRPC сервере, смотри файл auth.go, в пакете  auth (ключевое слово доступа к пакету может переиминовываться в import(?))

	return &App{
		log:        log,
		gRPCServer: gRPCServer,
		port:       port,
	}

}

// must функкция для Run функции, которая будет паниковать
// must - это в принципе, когда мы вместо возврата ошибки паникуем
func (a *App) MustRun() {
	if err := a.Run(); err != nil { // Если бы вы просто вызвали функцию Run(), это означало бы, что она должна быть определена как функция верхнего уровня, не связанная с конкретной структурой. В этом случае функция не имела бы доступа к полям структуры App и не могла бы использовать их.
		panic(err)
	}
}

func (a *App) Run() error {
	const op = "grpcapp.Run"

	log := a.log.With(slog.String("op", op), slog.Int("port", a.port)) // берётся существующий логгер и добавляются новые параметры к логу (оп и порт) за счёт метода With

	l, err := net.Listen("tcp", fmt.Sprintf(":%d", a.port)) // Listen - метод, который создаёт слушатель, который принимает TCP "tcp" соединения на указанном порту. И передаём порт, предварительно конвертировав его в строку с двоеточием
	if err != nil {
		return fmt.Errorf("%s: %w", op, err)
	}

	log.Info("grpc server is running", slog.String("addr", l.Addr().String())) // создаём лог сообщение (log.Info) с комментарием и l.Addr().String() - В контексте вашего кода, l — это переменная, которая содержит объект типа net.Listener. Этот объект создается с помощью функции net.Listen, и он представляет собой слушающий сокет, который ожидает входящие соединения на указанном адресе и порту. Метод Addr() — это метод интерфейса net.Listener. Он возвращает адрес, на котором слушает данный слушатель (то есть сервер).
	// ТАК ЖЕ ВАЖНО, КАКЕ ТО ЧТО НА СТРОЧКУ ВЫШЕ Тип возвращаемого значения: Метод Addr() возвращает интерфейс типа net.Addr. Этот интерфейс имеет метод String(), который позволяет получить строковое представление адреса.

	if err := a.gRPCServer.Serve(l); err != nil { // Метод Serve вызывается на объекте gRPC сервера (a.gRPCServer) с передачей слушателя l.  Запуск сервера: Когда вы вызываете Serve, он начинает слушать входящие соединения на указанном адресе и порту, который был задан при создании Listener. 2. Обработка соединений: Serve будет блокирующим вызовом, что означает, что выполнение программы приостанавливается до тех пор, пока сервер работает. Он будет обрабатывать входящие запросы, создавая для каждого соединения отдельную горутину (параллельный поток выполнения), чтобы обрабатывать запросы асинхронно.

		return fmt.Errorf("%s: %w", op, err)
	}

	return nil

}

func (a *App) Stop() {
	const op = "grpcapp.Stop"

	a.log.With(slog.String("op", op)).Info("grpc server is stopped", slog.Int("port", a.port)) // это временный лог, который вызывается можно сказать сразу как и написали, нигде не нужно применять какие то слова для запуска, но его нельзя испоьзовать в других частях функции, это всё из за отстутствия конструкции log := (но это решается следующим образом: пишу ниже)
	// log := a.log.With(slog.String("op", op), slog.Int("port", a.port))
	// log.Info("grpc server is stopped")

	a.gRPCServer.GracefulStop()
}
