#ЭТО ВСЁ ЯВЛЯЕТСЯ ПРИМЕРОМ, ТАК КАК СЕРВЕР ДЛЯ ПРОДАКШЕНА НЕ БЫЛ КУПЛЕН, НЕКУДА ДЕПЛОИТЬ
name: Deploy App #Зачем нам это нужно: Помогает легко находить и различать рабочие процессы в интерфейсе GitHub Actions.

on: #Определяет событие, которое активирует рабочий процесс.
  workflow_dispatch: #В вашем случае используется workflow_dispatch, что означает ручное выполнение рабочего процесса через интерфейс GitHub.
    inputs: #опредееляет водные данные
      tag: #имя переменной
        description: 'Tag to deploy' # Описание переменной, отображаемое в интерфейсе GitHub.
        required: true #Переменная обязательна для заполнения перед запуском.

#Когда вы нажимаете кнопку запуска рабочего процесса в GitHub, появляется форма с полем для ввода значения 
#переменной tag. После ввода значения и нажатия кнопки запуска GitHub передает это значение внутрь рабочего процесса.

#Далее, в остальной части YAML-файла (которая у вас пока не показана), вы используете эту переменную в заданиях (jobs) и шагах (steps).
#Например, вы можете передать этот тег в команду сборки или развертывания.

#jobs: — это список шагов, которые GitHub Actions должен пройти, чтобы завершить свою работу успешно. Эти шаги называют этапами или заданиями.
jobs: 
  deploy: #название конкретного задания (job). В данном примере оно называется deploy, подразумевая этап развёртывания приложения.
    runs-on: ubuntu-latest #хотим что бы работало на операционной системе ubuntu на последней версии
    env: 
      HOST: root@185.10.184.27185.10.184.27 #хост, купленного сервера, на котором и запускается проект | root - имя пользователя
      DEPLOY_DIRECTORY: /root/apps/grpc-auth #указываем директорию, в которую будет происходить деплой(директоряи на удалённом сервере)
      CONFIG_PATH: /root/apps/grpc-auth/config/prod.yaml #путь до конфига, она повторяет путь предыдущеего шага, но с имени config идёт путь уже внутри проекта к файлу конфига

# steps - это шаги, которые github actions должен выполнить
    steps: 
        - name: Checout repository # названеи операции: "загрузить репозиторий" (проще говоря показываем репозиторий) 
          uses:  action/checkout@v2 
          with: #внутри этого раздела находятся параметрыпередаваемые действию
            ref: ${{ github.event.inputs.tag }} # мы в ручную при запуске приложения указываем версию приложения(Зайти в GitHub → Нажать «Run Workflow» → Указать тег v1.0 → Готово! Система сама найдёт и установит именно первую версию.), программа сохраняет тег версии(тег версии это и есть штука типо v1.0 к примеру, которую мы указываем самомстоятельно при коммите на гитхаб, | (щас будет касаемо того, из зач его и что сохраняется в эту переменную) и так же мы самостоятельно указываем через интерфейс гитхаба какую что бы именно гитхаб запустил/собрал версию, из всех что ты коммитил) в переменную github.event.inputs.tag(и даллее в работе с github actions мы можем рпименять её ниже в коде и работать с ней/отталкиваясь от неё) и гитхаб продолжает свою работу именно с этой версией (Допустим, вы сделали две версии игры: v1.0 и v2.0. Теперь, если вам нужно установить старую версию, вы просто вводите v1.0, и система соберёт именно её.)
        - name: Check if tag exists # название операции: "проверить наличие тега"
          run: |
            git fetch --all --tags 
            if ! git tag | grep -q "^${{ github.event.inputs.tag }}$"; then
            echo "error: Tag '${{ github.event.inputs.tag }}' not found"
            exit 1
            fi
        - name: Set up Go 
          uses: actions/setup-go@v2 #установка go
          with:
            go-version: 1.25.3
        - name: Build app 
          run: |
            go mod download
            go build -o grpc-auth ./cmd/sso 
          # ОЧЕНЬ ВАЖНО ДЛЯ ДАЛЬЕЙШЕГО ПОНИМАНИЯ ВСЕХ ПУТЕЙ В КОМАНДАХ параметр -o указывает каким именеем сохранить собранный исполняемый файл, в данном случае файл будет назван grpc-auth, по пути ./cmd/sso все файлы .go будут скомпилированы в исполняемый файл/бинарный файл под именем grpc-auth
        - name: Build migrator
          run: |
            go build -o migrator ./cmd/migrator
          # Команда go build компилирует Go-программу и создает исполняемый бинарный файл. Она собирает исходники программы, проверяя синтаксис и зависимости, и генерирует готовый исполняемый файл.
        - name: Deploy to VM #деплой на удалённый сервер, берём наш бинарник и отправляем его на удалённый сервер 
          run: | 
            sudo apt-get install -y ssh rsync
            echo "$DEPLOY_SSH_KEY" > deploy_key.pem
            chmod 600 deploy_key.pem
            ssh -i deploy_key.pem -o StrictHostKeyChecking=no ${{ env.HOST }} "mkdir -p ${{ env.DEPLOY_DIRECTORY }}"
            rsync -avz -e `ssh -i deploy_key.pem -o StrictHostKeyChecking=no` --exclude=`.git` ./ ${{ env.HOST}}:${{ env.DEPLOY_DIRECTORY }}
            rsync -avz -e 'ssh -i deploy_key.pem -o StrictHostKeyChecking=no' ./migrator ${{ env.HOST }}:${{ env.DEPLOY_DIRECTORY }}/migrator
          env:
            DEPLOY_SSH_KEY: ${{ secret.DEPLOY_SSH_KEY}} #ВАЖНО К ТОМУ КАК СКРИПТ ПОЛУЧАЕТ ДОСТУП К СЕКРЕТУ ${{ secrets.DEPLOY_SSH_KEY }} — это специальная конструкция, которая ссылается на секрет (secret), хранящийся в настройках твоего репозитория или организации в GitHub. Когда ты пишешь ${{ secrets.DEPLOY_SSH_KEY }}, это значит, что GitHub заменит это выражение значением, указанным в соответствующем секрете.
            # ssh - пакет для подключения по ssh к удалённому серверу
            # rsync - пакет для синхронизации/передачи файлов между локальным и удалённым сервером
            # sudo даёт уроень привелегий администратора для установки ssh и rsync, пользователи лишь от уровня администратор имеют возможность устанавливать какие то пакеты
            # -y - для терминала ответ ДА(всегда соглашатся на продолжение установки) в случае запроса на продолжение установки пакетов
            # echo -  используется для вывода текста на экран терминала. В данном контексте её цель — записать значение переменной окружения $DEPLOY_SSH_KEY в файл deploy_key.pem. Таким образом, SSH-ключи сохраняются локально для последующего использования командой ssh.
            # далее после echo достаём из переменной окуржения github actions секретный ключь, и записываем его в файл deploy_key.pem
            # chmod 600 - Здесь назначаются специальные права(код 600 - обозначает уровень доступа: владелец) доступа к файлу deploy_key.pem. Только сам владелец файла сможет смотреть и менять его содержимое. Все остальные пользователи на компьютере не смогут его видеть или трогать.
            # ${{ env.HOST }} - переменная с адресом удалённого сервера, то есть куда именно результаты команд будут идти и что изменять
            # -i deploy_key.pem: эта опция указывает программе ssh, каким именно ключом пользоваться для входа. Ранее мы создали файл deploy_key.pem, содержащий приватный ключ, и теперь он пригодится.
            # -o StrictHostKeyChecking=no - команда означает отсутствие проверки сертификата, тоесть доверенное ли это устройство, В ПРОДАКШЕНЕ НЕ СПОЛЬЗОВАТЬ
            # "mkdir -p ${env.DEPLOY_DIRECTORY}": когда ты попадаешь на удалённый сервер, следующая задача — создать нужную директорию. Именно для этого служит команда mkdir. Параметр -p гарантирует, что если какая-то промежуточная папка отсутствует, она тоже будет создана.
            #  -a: режим архива. Он включает сохранение структуры каталогов, временных отметок и прав доступа. -v: подробный вывод информации о передаче файлов. Очень полезно, если хочется посмотреть, какие файлы были переданы. -z: включение компрессии данных. Твои файлы сжимаются перед отправкой, что ускоряет процесс передачи. -e ssh: мы снова используем ssh, потому что это безопасный метод доставки файлов.
            # -i deploy_key.pem: использование нашего SSH-ключа для авторизации. --exclude=.git: исключение папки .git из списка файлов, подлежащих отправке. Папка .git используется системой контроля версий Git и совершенно не нужна на сервере.
            # ./: обозначает текущую рабочую директорию, откуда начнутся поиски файлов для отправки. ${env.HOST}:${env.DEPLOY_DIRECTORY}: пункт назначения, состоящий из адреса удалённого сервера и директории, в которой будут размещены файлы.
            # rsync сразу говорит, какое действие будет производится, а именно передача файлов. А далее идут уточнающие аргументы, что передавать, куда передавать и так ./migrator - говорит о том, что мы хотим перенести все файлы из этой папки. { env.HOST }: это адрес сервера (IP или название). { env.DEPLOY_DIRECTORY }: это путь на сервере, куда положить файлы.
        - name: Remmove old systemed service file # удаляем устаревший файл службы, нужно что бы при обновлениях не возникало конфликтов  
          run: |
            ssh -i deploy_key.pem -o StrictHostKeyChecking=no ${{ env.HOST }} "rm -f /etc/systemd/system/sso.service"
        - name: List workspace contents
          run: |
            echo "Listining deployment folder contents:"
            ls -la ${{ github.worcspace }}/deployment
          #  - ls — команда для отображения содержимого текущего или указанного каталога. - -l — ключ, включающий детализированный («long») вывод информации о файлах, включая права доступа, владельца, группу, размер, дату последнего изменения и название файла. - -a — ключ, показывающий также скрытые файлы (те, имена которых начинаются с точки ., например, .gitignore).
          # ${{ github.workspace }}/deployment: это специальная переменная, обозначающая рабочую область в окружениях CI/CD (Continuous Integration/Continuous Delivery), используемых в системах вроде GitHub Actions.
          # Директория github.workspace — это корневая рабочая директория, куда загружены файлы вашего проекта, когда вы инициируете процесс сборки или тестирования.
          #  Часть /deployment говорит о том что мы выводим содержимое папки, нахлдящайся уже внутр окружения github actions. Эта папка содержит файл конфигурации для sytemd. Это нужно для проверки достоверности нахождения файла конфигурации systemd по этому пути. К слову если нужно просмотреть содержимое файлов можно использовать такие комнады как cat и less.  
        - name: Copy systemd service file # В кратце и макимально понятно, этим шагом мы капируем актуальный файл конфигурации systemd на удалённый сервер, что бы он мог запускать наш сервис.
          run: |
            scp -i deploy_key.pem -o StrictHostKeyChecking=no ${{ github.workspace }}/deployment/grpc-auth.service ${{ env.HOST }}:/tmp/grpc-auth.service 
            ssh -i deploy_key.pem -o StrictHostKeyChecking=no ${{ env.HOST }} "mv /tmp/grpc-auth.service /etc/systemd/system/grpc-auth.servicve" 
          # # SCP (Secure CoPy): Безопасный протокол копирования файлов по сети, использующий SSH-подключение.
          # (там где scp) Отправить файл `grpc-auth.service`, лежащий в директории `deployment` моего рабочего пространства GitHub Actions, на удалённый сервер с адресом `$HOST`, сохранив его во временную директорию `/tmp`, подтвердив свою личность закрытым ключом `deploy_key.pem` и отключив проверку подлинности сервера.
          # Команда mv переносит файл из временного каталога в постоянный.
          # Подключиться к удалённому серверу, указанному в переменной $HOST, используя закрытый ключ deploy_key.pem, отключить проверку подлинности хоста и переместить файл конфигурации gRPC-сервисов из временной директории /tmp в постоянную /etc/systemd/system.
        - name: Run migrations # Запускаем миграции на удалённом сервере
          run: |
            ssh -i deploy_key.pem -o StrictHostKeyChecking=no ${{ env.HOST }} "${{ env.DEPLOY_DIRECTORY }}/migrator --storage-path=${{env.DEPLOY_DIRECTORY }}/sso.db --migrations-path={{ env.DEPLOY_DIRECTORY }}/migrations"
          # подключаемся к удалённому серверу, с ключами всё как обычно, во второй части скрипта, даём утилите для миграций указания где лежат все нужные для её запуска аргументы, то ест ьгде лежит сама бд, после чего говорим где лежат сами миграции(это происходит на удалённом сервере(так как мы запускаем миграции))  --storage-path, --migrations-path - это названеи аргументов, в которые кладётся путь к указанной папке/файлу и передаётся папке /migrator Значение, указанное после =, подсказывает утилите точный путь к файлу.  
        - name: Start application # Запускаем наш сервис на удалённом сервере. 
          run: |
            ssh -i deploy_key.pem -o StrictHostKeyChecking=no ${{ env.HOST }} "systemctl deamon-reload && systemctl restart grpc-auth.service"
          # первая половина последей команды аналогично пред идущей 
          # systemctl daemon-reload: команда перезагрузки демона systemd, чтобы он прочитал новые конфигурационные файлы сервисов. Зачем нам это делать? Мы не можем удалить и добавить новй конфиг файл ан его место, не дав проситать systemd. Иначе systemd просто не прочитает изменения и будет работаьь оп обрпзцу старого конфигурационного файла, тем самым всё будет работать не корректно, если вообще будет работать. Вы внесли изменения в файл сервиса, скопировали его в нужную директорию, но... ничего не произошло. Почему? Дело в том, что операционная система Linux сохраняет копию текущих конфигураций, чтобы быстро их применять. Она не отслеживает автоматически, поменялись ли файлы или нет. Вот тут и вступает в дело команда daemon-reload. Она буквально заставляет систему перечитать все сохранённые файлы и убедиться, что используются самые свежие настройки.
          # &&: оператор последовательного выполнения команд, означающий, что вторая команда выполнится только после успешного завершения первой.
          # systemctl restart grpc-auth.service: команда перезагрузки указанного сервиса (grpc-auth.service), чтобы новые настройки конфига вступили в силу.
          # Без daemon-reload служба могла бы продолжать работать со старыми настройками, и ваше изменение могло бы оказаться бесполезным.
# ВАЖНО ПОНЯТЬ, БУДУ С ЭТИМ РАБОТАТЬ!!!Systemd — это менеджер инициализации процессов в современных дистрибутивах Linux. Проще говоря, это специальная программа, управляющая всеми остальными программами, включая сервисы, фоновые процессы и приложения. Systemd следит за тем, чтобы нужные программы стартовали вовремя, были настроены правильно и могли взаимодействовать друг с другом.
# ВАЖНО ПОНЯТЬ, БУДУ С ЭТИМ РАБОТАТЬ!!!demon systemd - это демон инициализации, он управляет процессами инициализации, то есть как в нашем файле по сборке systemd и указано, демон запускает приложение(в зависисмости от посталенных условий, этим условием может явдятся запуск приложения, только когда система достигент определённого состояния или когда определённое событие произошло). Или же demon systemd умеет пытаться вновь перезапускать сервис в случае возникновения ошибки и подобные фоновые процессы, которые пользователь не видит и не может остановить.