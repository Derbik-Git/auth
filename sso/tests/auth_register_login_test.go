package tests

import (
	"GRPC/sso/tests/suite"
	"testing"
	"time"

	ssov1 "github.com/Derbik-Git/protos"
	"github.com/brianvoe/gofakeit"
	"github.com/golang-jwt/jwt/v5"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const (
	emptyAppID = 0             // идентификатор не поддерживаемого приложения(тест должен вернуть ошибку)
	appID      = 1             // идентификатор поддерживаемого приложения(должен возврашать правильный ответ)
	appSecret  = "test-secret" // серетный код приложения, который определяет доверенное приложение

	passDefaultLen = 10 // максимальная длинна пароля по умолчанию(если пароль слишком короткий, система сообщит об этом)
)

/*
1. Создание фейк-данных для пользователя (почта и пароль).
2. Регистрация нового пользователя с использованием этих данных.
3. Авторизация пользователя и получение токена.
4. Парсинг полученного токена и проверка его подписи.
5. Извлечение данных из токена.
6. Привежение к типу claims, для проверки всех полученных значений/переменных.
7. Проверка всех полученных значений/переменных.
8.
*/
func TestRegisterLogin_Login_HappyPath(t *testing.T) {
	ctx, st := suite.New(t)

	email := gofakeit.Email()
	pass := gofakeit.Password(true, true, true, true, false, passDefaultLen)

	respReg, err := st.AuthClient.Register(ctx, &ssov1.RegisterRequest{ // регистрируем и создаём структуру фейкового пользователя, который выполняте запрос
		Email:    email,
		Password: pass,
	})
	require.NoError(t, err)               //  require — это пакет внутри testify, который предоставляет функции, которые останавливают выполнение теста, если условие не выполнено.  NoError проверяет, что переданная ошибка (err) равна nil. Если ошибка не равна nil, тест будет завершён с ошибкой, и будет выведено сообщение об ошибке.
	assert.NotEmpty(t, respReq.GetUserId) // - GetUserId — это автоматически созданный методом компилятором Protobuf для удобной работы с полем user_id. // assert: Это пакет, который предоставляет функции для утверждений (assertions) в тестах. Утверждения — это проверки, которые вы делаете в тестах, чтобы убедиться, что ваш код работает так, как ожидается.

	respLogin := st.AuthClient.Login(ctx, &ssov1.LoginRequest{
		Email:    emmail,
		Password: pass,
		AppId:    appID,
	})
	require.NoError(t, err)

	loginTime := time.Now() // время авторизации, это для проверки время действия токена

	token := respLogin.GetToken()
	require.NotEmpty(t, token)

	// это функция парсит токен, которыйм мы указали, а потом она принимаемой, анонимной функцией запрашивает таким образом у разработчика секрет, для того что бы библиотка поняла, каким именно ключом был зашифрован этот токен
	tokenParsed, err := jwt.Parse(token, func(token *jwt.Token) (interface{}, error) { // Чтобы проверить подпись токена, библиотека должна знать, каким именно ключом он был зашифрован. Поскольку ключ заранее неизвестен самой библиотеке, она запрашивает его у разработчика, вызывая эту функцию
		return []byte(appSecret), nil
	})
	require.NoError(t, err)

	claims, ok := tokenParsed.Claims.(jwt.MapClaims) // проверяем распаршеный токен на тип jwt.MapClaims, который подрузомевает наличие мапы с payload токена, payload - полезные данные в токене, например когда истекает время действия токена, или имя пользователя, которому был рисвоен токен
	require.True(t, ok)

	// все полученные значения мы проверяем на соответствие ожидаемым
	assert.Equal(t, respReq.GetUserId(), int64(claims["uid"].(float64)))
	assert.Equal(t, email, claims["email"].(string))
	assert.Equal(t, appID, int64(claims["app_id"].(float64)))

	const deltaSeconds = 1

	// В отличие от простого сравнения чисел с помощью assert.Equal, метод InDelta учитывает небольшую разницу между двумя величинами. Это полезно, когда абсолютное равенство сложно обеспечить (например, из-за временных задержек сети или особенностей измерения времени).
	assert.InDelta(t, loginTime.Add(st.Cfg.TokenTTL).Unix(), claims["exp"].(float64), deltaSeconds) // первым делом мы ко времени с момента создания токена добавляем время жизни токена из конфига - так мы можем знать момент времени, когда токен должен истечь, благодаря .Unix() мы полученное время превращаем в секунды(так удобнее скалдывать время, смотреть и считать), сравниваем его со значением в токене(мы указывали "exp" при создании токена), deltaSeconds - это допустимое отклонение в секундах(в нашем случае 5 секунд), то есть если то что в токене не совпадает с отмеренным нами временем в пределах 5-ти секунд, то это ничего страшного, это делается для того что бы тест не ложился просто так, а просто так это потому чт опогрешнасть будет в любом случае, так как отмеряемое нами время при получении токена отличается от настоящего времени создания токена, так как loginTime - это все го литшь импровизация этого времени для теста, ибо мы не знаем когда именно токен был создан

} // к слову при запуске тестов мы указываем путь к тестовым миграциям, то есть уазываем путь не к основным миграциям при запуске, а тестовым и таблица будет отдельная и называться migrations_test

// обратный тест, пред идущему, в данном случаем мы хотим положить приложенеи, а именно мы попробуем 2 раза зарегестрироваться, что не должно допускаться в нашем сервисе
func TestRegisterLogin_DuplicationRegistration(t *testing.T) {
	ctx, st := suite.New(t)

	email := gofakeit.Email()
	pass := gofakeit.Password(true, true, true, true, false, passDefaultLen)

	respReg, err := st.AuthClient.Register(&ssov1.RegisterRequest{ // забыл кстати сказать, особо не вдумываемся, просто переменаая называется ответ регистрации, хоть мы и создаём по сути фейковый запрос, а не ответ, но вообщем это всё так потмоу что этот самый запрос автоматически возвращает ответ, поэтому мы и называем переменную имемнем ответа
		Email:    email,
		Password: pass,
	})
	require.NoError(t, err)
	assert.NotEmpty(t, respReg.GetUserId)

	respReg, err := st.AuthClient.Register(&ssov1.RegisterRequest{
		Email:    email,
		Password: pass,
	})
	require.NoError(t, err)
	assert.NotEmpty(t, respReg.GetUserId)
	assert.ErrorContains(t, err, "user already exists") // Эта функция проверяет, содержится ли определённая строка в тексте ошибки, полученной в результате теста. Если такая строка найдена, проверка считается успешной. Если же строка отсутствует, значит, произошла непредвиденная ошибка, и тест провалится.

}
